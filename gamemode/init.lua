---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Комерад.
--- DateTime: 5/22/2018 10:15 PM
---

AddCSLuaFile( "cl_init.lua" )
AddCSLuaFile( "cl_pickteam.lua" )
AddCSLuaFile( "cl_researchmenu.lua" )
AddCSLuaFile( "cl_hud.lua" )
AddCSLuaFile( "cl_scoreboard.lua" )
AddCSLuaFile( "shared.lua" )
AddCSLuaFile("util.lua")

include( "shared.lua" )
include( "player.lua" )
include( "player_ext.lua" )
include( "komerad_autorun.lua" )
include( "research_manager.lua" )
include( "research_category.lua" )
include( "research_technology.lua" )

-- Convars --
CreateConVar("rm_map_time_limit", "30", FCVAR_NOTIFY + FCVAR_REPLICATED)
CreateConVar("rm_auto_vote_time_seconds", "30", FCVAR_NOTIFY + FCVAR_REPLICATED)
CreateConVar("rm_vote_time_limit_seconds", "60", FCVAR_NOTIFY + FCVAR_REPLICATED)

--[[All local spaced server functions]]

local function EndRound()
--   print("THE ROUND HAS ENDED!!!!!!!!")
   local text = "The round has ended"

   -- announce to players
   for k, ply in pairs(player.GetAll()) do
      if IsValid(ply) then
         ply:PrintMessage(HUD_PRINTTALK, text)
      end
   end

   timer.Simple( 15, function() game.LoadNextMap() end )
end

local function InitGamemodeVariables()

end

local function SetRoundEnd(endtime)
   SetGlobalFloat("rm_map_end", endtime)
end

--function IncRoundEnd(incr)
--   SetRoundEnd(GetGlobalFloat("rm_round_end", 0) + incr)
--end

local function InitMapEndTimer()
   timer.Create( 'mapendtimer', GetConVar("rm_map_time_limit"):GetInt() * 60, 1, EndRound )
end

local function InitRoundEndTime()
   -- Init round values
   local endtime = CurTime() + (GetConVar("rm_map_time_limit"):GetInt() * 60)

   SetRoundEnd(endtime)
end

local function InitTeamVariables()
   local AllTeams = team.GetAllTeams()
   for ID, TeamInfo in pairs ( AllTeams ) do
      if ( ID ~= TEAM_CONNECTING and ID ~= TEAM_UNASSIGNED and ID ~= TEAM_SPECTATOR ) then
         PrintTable(TeamInfo)
         local newResearchManager = ResearchManager(ID, TeamInfo['Name'])
         local armorCat = newResearchManager:AddCategory('armor', 'Armor')
         local armor_one = armorCat:AddTechnology('armor_one', 'Armor Type I', 'Decent Armor (20)', 60)
         local armor_two = armorCat:AddTechnology('armor_two', 'Armor Type II', 'Decent Armor (40)', 65)
         table.insert(armor_two.reqs, armor_one.key)

         PrintTable(newResearchManager)
         TeamInfo.ResearchManager = newResearchManager
         TeamInfo.Money = 30000 -- Every team gets $30,000 to start
         TeamInfo.Scientists = 3 -- Every team gets 3 to start

         local menu_vote_time = GetConVar("rm_vote_time_limit_seconds"):GetInt()
         timer.Create("Team" .. ID .. "VoteMenuTimeLimit", menu_vote_time, 1, function() newResearchManager:TallyVotes() end)
      end
   end
end

local function PrintTimeLeft()
   --print(GetGlobalFloat("rm_round_end", 0) - CurTime())
   --print(util.SimpleTime( math.max(0, GetGlobalFloat("rm_map_end", 0)) - CurTime(), "%02i:%02i"))
   local endtime = GetGlobalFloat("rm_map_end", 0) - CurTime()
   local text  = util.SimpleTime(math.max(0, endtime), "%02i:%02i")
--   print(text)
end

--[[All GM: spaced functions]]

function GM:Initialize()

   GAMEMODE.playermodel = "models/player/phoenix.mdl"

   InitGamemodeVariables()
   InitTeamVariables()

   local AllTeams = team.GetAllTeams()

	-- Do stuff
   InitMapEndTimer()
   --local ptime = GetConVar("ttt_preptime_seconds"):GetInt()
   InitRoundEndTime()

   --hook.Add("Tick", "PrintTimeLeft", PrintTimeLeft )
end

function GM:ShowHelp( ply ) -- This hook is called everytime F1 is pressed.
    umsg.Start( "OpenResearchMenu", ply ) -- Sending a message to the client.
    umsg.End()
end --Ends function

-- Convar replication is broken in gmod, so we do this.
-- I don't like it any more than you do, dear reader.
-- Saw this in TTT, seems like a good idea to replicate for our timer.
function GM:SyncGlobals()
   SetGlobalInt("rm_map_time_limit", GetConVar("rm_map_time_limit"):GetInt())
end

--[[All global server functions]]

function GetTeamInfoTable(teamIndex)
   local AllTeams = team.GetAllTeams()
   return AllTeams[teamIndex]
end